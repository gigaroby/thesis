\chapter{MeshChat}

\section{Introduction}
MeshChat is a mobile application that allows Bluetooth-enabled smartphones to exchange messages without the need for an Internet connection.
This approach is especially useful in contexts where the access to the Internet may be absent or severely censored by a central authority.
It is implemented as a native Android application.

\subsection{Android}
\dots

\subsection{Bluetooth on Android}
Older versions of Android relied on BlueZ \cite{bluez} as the implementation of the Bluetooth stack.
Since version 4.2, BlueZ has been replaced by BlueDroid \cite{bluedroid}, an implementation of the Bluetooth Stack developed by Broadcom. 

The Android SDK only provides RFCOMM as the transport layer \cite{android_rfcomm} and wraps it into a Java Socket \cite{android_rfcomm_java_socket}. 

\dots

\section{Architectural Overview}
The application is split into two main components: the UI layer and the communication service.
Each of these runs in its own process, and the communication between the two happens via a form of message passing provided by the Android System \cite{android_message}.

\subsection{User Interface}
\dots

\subsection{Communication Layer}
The communication layer is the component of the application that handles all aspects of communication with other devices.
Its responsibilities include discovering new devices, sending messages over the air and listening for incoming messages.
It is organized as a set of two permanent threads and a fixed-size thread pool of workers.

The discovery thread is tasked with discovering new devices whenever they become available.
It does so by periodically turning on and off the inquiry scan of the Bluetooth device.
Both the amount of time between discoveries and the length of the discovery itself are configurable parameters.
Since the inquiry scan severely impacts the performance of the connection, outgoing messages are queued until the scan is completed.

The listening thread awaits for connections from other devices. When a new connection is detected a worker thread which will handle the new connection is created and put in a queue.

The thread pool waits for jobs to be available in the queue.
As soon as a job is available one of the free worker threads is tasked with executing the job.
Constraining the number of concurrent worker threads is especially convenient on a mobile device where reducing battery usage is a priority.

\subsection{Dissemination protocol}
When a message is received the application relays it to everyone but the original sender.
At the moment the only supported message is a ping.